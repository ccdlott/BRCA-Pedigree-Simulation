import random
from datetime import datetime
now = datetime.now()
year = now.year

class Pedigree(object):
    '''
    The following definitions/abbreviations are used throughout this class
    Fam ID: Unique family ID
    Ind ID: Unique individual ID
    Target: 1 = proband, 0 = other members of pedigree
    Moth ID: unique ID of mother of individual
    Fath ID: unique ID of father of individual
    Gender: gender of individual
    Twin: 1 = monozygotic twin, 0 = not monozygotic twin
    Dead: 1 = dead, 0 = alive
    Age: represents either current age or age at death
    Birth Year: birth year of individual
    BrCa_1: integer = age at 1st breast cancer diagnosis, 0 = unaffected
    BrCa_2: integer = age at 2nd breast cancer diagnosis, 0 = unaffected
    OvCa: integer = age at diagnosis of ovarian cancer, 0 = unaffected
    ProCa: integer = age at diagnosis of prostate cancer, 0 = unaffected
    PanCa: integer = age at diagnosis of pancreatic cancer, 0 = unaffected
    G Test: genetic test 0 = untested, S = mutation search, 
            T = direct gene test
    Mutn: mutation status 0 = untested, N = no mutation, 1 = BRCA 1+, 2 =
          BRCA2+, 3 = BRCA1+ and BRCA2+
    Ashkn: 0 = not Ashkanzi, 1 = Ashkenazi
    For the follwoing variables 0 = unaffected, N = neagtive, P = positive
    ER: Estrogen receptor status
    PR: = Progesteron receptor status
    HER2: = Human epidermal growth factor receptor status
    CK14: Cytokeratin 14 status 
    CK56: Cytokeratin 56 status
    '''

    family_id = 0
    ind_id = 0

    def __init__(self):
        '''Initializes a unique family ID for each instance of a pedigree'''
        Pedigree.family_id += 1

    def get_family_id(self):
        '''Returns unique family ID when called'''
        return self.family_id

    def get_ind_id(self):
        '''Returns unique individual ID when called'''
        Pedigree.ind_id += 1
        return self.ind_id

    def get_gender(self):
        '''Randomly returns either M for male or F for female when called'''
        gender = random.randint(1,2)
        if gender == 1:
            return "M"
        else:
            return "F"
        
    def init_proband(self):
        '''
        Initializes the proband for the pedigree and returns a list in
        the format:
        [FamID, Ind ID, Target, Moth ID, Fath ID, Gender, Twin, Dead,
        Age, Birth Year, BrCa_1, BrCa_2, OvCa, ProCa, PanCa, G Test, 
        Mutn, Ashkn, ER, PR, HER2, CK14, CK56]
        '''
        fam_id = self.get_family_id()
        person_id = self.get_ind_id()
        target = 1
        moth_id = None
        fath_id = None
        gender = self.get_gender()
        twin = 0
        dead = 0
        age = random.randint(20,65)
        birth_year = int(year)-int(age)
        br_ca_dx1 = 0
        br_ca_dx2 = 0
        ov_ca_dx = 0
        pro_ca_dx = 0
        pan_ca_dx = 0
        g_test = 0
        mutn = 0
        ashkn = 0
        ER = 0
        PR = 0
        HER2 = 0
        CK14 = 0
        CK56 = 0
        proband = []
        variables = [fam_id, person_id, target, moth_id, fath_id,
                    gender, twin, dead, age, birth_year, br_ca_dx1,
                    br_ca_dx2, ov_ca_dx, pro_ca_dx, pan_ca_dx, g_test,
                    mutn, ashkn, ER, PR, HER2, CK14, CK56]
        for variable in variables:
            proband.append(variable)
        return proband

##to debug init_proband
#x = 1
#while x <= 5:
#    new_ped = Pedigree()
#    new_proband = new_ped.init_proband()
#    print "Proband", x
#    print new_proband
#    x += 1

    def add_parents(self, person):
        '''
        Adds parent information for an individual
        Returns a list of lists with information for child, mother,
        father in the following format:
        [Fam ID, Ind ID, Target, Moth ID, Fath ID, Gender, Twin, Dead,
        Age, Birth Year, BrCa_1, BrCa_2, OvCa, ProCa, PanCa, G Test, Mutn,
        Ashkn, ER, PR, HER2, CK14, CK56]
        '''
        person_moth_id = person[3]
        person_fath_id = person[4]
        if person_moth_id == None and person_fath_id == None:
            fam_id = person [0]
            person_moth_id = self.get_ind_id()
            person_fath_id = self.get_ind_id()
            moth_id = None
            fath_id = None
            target = 0
            moth_gender = "F"
            fath_gender = "M"
            twin = 0
            child_age = int(person[8])
            moth_age = random.randint(child_age + 20, child_age + 40)
            fath_age = random.randint(child_age + 20, child_age + 40)
            moth_birth_year = int(year) - int(moth_age)
            fath_birth_year = int(year) - int(fath_age)
            if moth_age > 90:
                moth_dead = 1
                moth_age = 91
            else:
                moth_dead = 0
            if fath_age > 90:
                fath_dead = 1
                fath_age = 91
            else:
                fath_dead = 0
            br_ca_dx1 = 0
            br_ca_dx2 = 0
            ov_ca_dx = 0
            pro_ca_dx = 0
            pan_ca_dx = 0
            g_test = 0
            mutn = 0
            ashkn = 0
            ER = 0
            PR = 0
            HER2 = 0
            CK14 = 0
            CK56 = 0
            moth_variables = [fam_id, person_moth_id, target, moth_id,
                              fath_id, moth_gender, twin, moth_dead, moth_age,
                              moth_birth_year, br_ca_dx1, br_ca_dx2,
                              ov_ca_dx, pro_ca_dx, pan_ca_dx, g_test,
                              mutn, ashkn, ER, PR, HER2, CK14, CK56]
            fath_variables = [fam_id, person_fath_id, target, moth_id,
                              fath_id, fath_gender, twin, fath_dead, fath_age,
                              fath_birth_year, br_ca_dx1, br_ca_dx2,
                              ov_ca_dx, pro_ca_dx, pan_ca_dx, g_test,
                              mutn, ashkn, ER, PR, HER2, CK14, CK56]
            mother = []
            for variable in moth_variables:
                mother.append(variable)
            father = []
            for variable in fath_variables:
                father.append(variable)
            person[3] = person_moth_id
            person[4] = person_fath_id
            parents = []
            parents.append(mother)
            parents.append(father)
            return parents
        else:
            raise TypeError("This person already has parents")
        
##to debug add_parents
#x = 1
#while x <= 5:
#    new_ped = Pedigree()
#    print "Pedigree", x
#    new_proband = new_ped.init_proband()
#    new_parents = new_ped.add_parents(new_proband)
#    print "Proband", new_proband
#    print "Mother", new_parents[0]
#    print "Father", new_parents[1]
#    x += 1

##to debug expection to add_parents
#x = 1
#while x <= 5:
#    new_ped = Pedigree()
#    new_proband = new_ped.init_proband()
#    new_parents = new_ped.add_parents(new_proband)
#    other_parents = new_ped.add_parents(new_proband)

    def add_partner(self, person):
        '''
        Creates a partner given a specific person and randomly generates
        offspring for pair
        Returns a list of information for the new partner in
        the following format:
        [Fam ID, Ind ID, Target, Moth ID, Fath ID, Gender, Twin, Dead,
        Age, Birth Year, BrCa_1, BrCa_2, OvCa, ProCa, PanCa, G Test, Mutn,
        Ashkn, ER, PR, HER2, CK14, CK56]
        '''
        fam_id = person[0]
        partner_id = self.get_ind_id()
        partner_target = 0
        partner_moth_id = None
        partner_fath_id = None
        person_gender = person[5]
        if person_gender == "M":
            partner_gender = "F"
        else:
            partner_gender = "M"
        partner_twin = 0
        partner_dead = 0
        person_age = int(person[8])
        partner_age = random.randint(person_age - 15, person_age + 15)
        if partner_age > 90:
            partner_age = 91
            partner_dead = 1
        partner_birth_year = int(year)-int(partner_age)
        br_ca_dx1 = 0
        br_ca_dx2 = 0
        ov_ca_dx = 0
        pro_ca_dx = 0
        pan_ca_dx = 0
        g_test = 0
        mutn = 0
        ashkn = 0
        ER = 0
        PR = 0
        HER2 = 0
        CK14 = 0
        CK56 = 0
        partner = [fam_id, partner_id, partner_target,
                   partner_moth_id, partner_fath_id,
                   partner_gender, partner_twin,
                   partner_dead, partner_age, partner_birth_year,
                   br_ca_dx1, br_ca_dx2, ov_ca_dx,
                   pro_ca_dx, pan_ca_dx, g_test, mutn, ashkn, ER,
                   PR, HER2, CK14, CK56]
        return partner

##to debug add_partner
#x = 1
#while x <= 5:
#    new_ped = Pedigree()
#    new_pro = new_ped.init_proband()
#    family  = new_ped.add_parents(new_pro)
#    partner = new_ped.add_partner(new_pro)
#    family.append(partner)
#    print "Family", x
#    print "Mother", family[0]
#    print "Father", family[1]
#    print "Proband", new_pro
#    print "Proband Partner", family[2]
#    x += 1


    def add_offspring(self, person1, person2):
        '''
        Generates offrsping given 2 parents

        Returns a list of lists with each list representing one child in
        the following format:
        [Fam ID, Ind ID, Target, Moth ID, Fath ID, Gender, Twin, Dead,
        Age, Birth Year, BrCa_1, BrCa_2, OvCa, ProCa, PanCa, G Test, Mutn,
        Ashkn, ER, PR, HER2, CK14, CK56]
        '''
        fam_id = person1[0]
        if person1[5] == "F":
            moth_id = person1[1]
            fath_id = person2[1]
            moth_age = int(person1[8])
        else:
            moth_id = person2[1]
            fath_id = person1[1]
            moth_age = int(person2[8])
        num_children = random.randint(0,4)
        children = []
        for child in range(num_children):
            child_id = self.get_ind_id()
            child_target = 0
            child_gender = self.get_gender()
            child_twin = 0
            child_dead = 0
            child_age = random.randint(moth_age - 40, moth_age -
                        20)
            if child_age <= 0:
                child_age = 1
            child_birth_year = int(year) - int(child_age)
            br_ca_dx1 = 0
            br_ca_dx2 = 0
            ov_ca_dx = 0
            pro_ca_dx = 0
            pan_ca_dx = 0
            g_test = 0
            mutn = 0
            ashkn = 0
            ER = 0
            PR = 0
            HER2 = 0
            CK14 = 0
            CK56 = 0
            child_variables = [fam_id, child_id, child_target, moth_id,
                               fath_id, child_gender, child_twin, child_dead,
                               child_age, child_birth_year, br_ca_dx1,
                               br_ca_dx2, ov_ca_dx, pro_ca_dx,
                               pan_ca_dx, g_test, mutn, ashkn, ER,
                               PR, HER2, CK14, CK56]
            children.append(child_variables)
        return children

#to debug add_offspring
#x = 1
#while x <= 5:
#    new_ped = Pedigree()
#    new_pro = new_ped.init_proband()
#    new_part = new_ped.add_partner(new_pro)
#    new_children= new_ped.add_offspring(new_pro, new_part)
#    print "Pedigree", x
#    print "Parent 1", new_pro
#    print "Parent 2", new_part
#    for child in range(len(new_children)):
#        print "Child", child+1, new_children[child]
#    x += 1

    def add_siblings(self, person):
        '''
        Given a particular person, generates siblings. Parents must be
        initialized before creating any siblings

        Returns of list of lists containing the information for each
        siblings in the following format:
        [Fam ID, Ind ID, Target, Moth ID, Fath ID, Gender, Twin, Dead,
        Age, Birth Year, BrCa_1, BrCa_2, OvCa, ProCa, PanCa, G Test, Mutn,
        Ashkn, ER, PR, HER2, CK14, CK56]
        '''
        fam_id = person[0]
        moth_id = person[3]
        fath_id = person[4]
        person_age = int(person[8])
        if moth_id == None and fath_id == None:
            raise ValueError("Must add parents before adding siblings")
        else:
            num_sibs = random.randint(0,4)
            siblings = []

            for sib in range(num_sibs):
                sib_id = self.get_ind_id()
                sib_target = 0
                sib_gender = self.get_gender()
                sib_twin = 0
                sib_dead = 0
                sib_age = random.randint(person_age - 15, person_age +
                                         15)
                sib_birth_year = int(year) - int(sib_age)
                if sib_age > 90:
                    sib_dead = 1
                    sib_age = 91
                br_ca_dx1 = 0
                br_ca_dx2 = 0
                ov_ca_dx = 0
                pro_ca_dx = 0
                pan_ca_dx = 0
                g_test = 0
                mutn = 0
                ashkn = 0
                ER = 0
                PR = 0
                HER2 = 0
                CK14 = 0
                CK56 = 0
                sib_variables = [fam_id, sib_id, sib_target, moth_id,
                                 fath_id, sib_gender, sib_twin, sib_dead,
                                 sib_age, sib_birth_year, br_ca_dx1,
                                 br_ca_dx2, ov_ca_dx, pro_ca_dx,
                                 pan_ca_dx, g_test, mutn, ashkn, ER,
                                 PR, HER2, CK14, CK56]
                siblings.append(sib_variables)
            return siblings
#to debug add_siblings
#x = 1
#while x <= 5:
#    new_ped = Pedigree()
#    new_pro = new_ped.init_proband()
#    new_parents = new_ped.add_parents(new_pro)
#    new_sibs = new_ped.add_siblings(new_pro)
#    print "Pedigree", x
#    print "Mother", new_parents[0]
#    print "Father", new_parents[1]
#    print "Proband", new_pro
#    for sib in range(len(new_sibs)):
#        print "Sibling", sib+1, new_sibs[sib]
#    x += 1

    def make_pedigree(self):
        '''
        Randomly generates a pedigree of 3 generations with proband in
        final generation

        Returns a list of lists with information for each pedigree
        member in the following format:
        [Fam ID, Ind ID, Target, Moth ID, Fath ID, Gender, Twin, Dead,
        Age, Birth Year, BrCa_1, BrCa_2, OvCa, ProCa, PanCa, G Test, Mutn,
        Ashkn, ER, PR, HER2, CK14, CK56]
        '''
        pedigree = []
        proband = self.init_proband()
        pedigree.append(proband)
        pro_parents = self.add_parents(proband)
        pedigree.append(pro_parents)
        pro_siblings = self.add_siblings(proband)
        pedigree.append(pro_siblings)
        pro_moth_parents = self.add_parents(pro_parents[0])
        pedigree.append(pro_moth_parents)
        pro_fath_parents = self.add_parents(pro_parents[1])
        pedigree.append(pro_fath_parents)
        pro_moth_siblings = self.add_siblings(pro_parents[0])
        pedigree.append(pro_moth_siblings)
        pro_fath_siblings = self.add_siblings(pro_parents[1])
        pedigree.append(pro_fath_siblings)
        return pedigree

#to debug make_pedigree
#x = 1
#while x <= 5:
#    new_ped = Pedigree()
#    pedigree = new_ped.make_pedigree()
#    proband = pedigree[0]
#    mother = pedigree[1][0]
#    father = pedigree[1][1]
#    pro_siblings = pedigree[2]
#    pro_moth_parents = pedigree[3]
#    pro_fath_parents = pedigree[4]
#    pro_moth_sibs = pedigree[5]
#    pro_fath_sibs = pedigree[6]
#    print "Pedigree", x
#    print "Maternal Grandmother", pro_moth_parents[0]
#    print "Maternal Grandfather", pro_moth_parents[1]
#    print "Paternal Grandmother", pro_fath_parents[0]
#    print "Paternal Grandfather", pro_fath_parents[1]
#    for sib in range(len(pro_moth_sibs)):
#        print "Mother's Sibling", sib+1, pro_moth_sibs[sib]
#    for sib in range(len(pro_fath_sibs)):
#        print "Father's Sibling", sib+1, pro_fath_sibs[sib]
#    print "Mother", mother
#    print "Father", father
#    print "Proband", proband
#    for sib in range(len(pro_siblings)):
#        print "Proband Sibling", sib+1, pro_siblings[sib]
#    x += 1

    def write_pedigree(self, pedigree):
        '''
        Writes pedigree in output specific for BOADICEA import to file pedigree.txt
        '''
        formatted_pedigree = []
        proband = pedigree.pop(0)
        formatted_pedigree.append(proband)
        for lst in pedigree:
            for person in lst:
                formatted_pedigree.append(person)
        new_f = "pedigree.txt"
        my_pedigree = open(new_f, "w")
        my_pedigree.write("BOADICEA import pedigree file format 2.0 \n")
        headers = ["FamID", "Target", "IndID", "FathID", "MothID",
                   "Sex", "Twin", "Dead", "Age", "Yob", "1BrCa",
                   "2BrCa", "OvCa", "ProCa", "PanCa", "Gtest", "Mutn",
                   "Ashkn", "ER", "PR", "HER2", "CK14", "CK56"]
        for item in headers:
            my_pedigree.write("%s \t" % item)
        my_pedigree.write("\n")
        for person in formatted_pedigree:
            for info in person:
                my_pedigree.write("%s \t" % info)
            my_pedigree.write("\n")
        my_pedigree.close()
    
##to debug write_pedigree
#new_ped = Pedigree()
#pedigree = new_ped.make_pedigree()
#w_ped = new_ped.write_pedigree(pedigree)

class Family(object):
    '''
    Represents a randomly g
    enerated pedigree given particular
    assumptions: Maximum number of generations per family = 4
                 Maximum number of children per pair = 10
    
    Contains functions to generate:
        get_family_ID = unique ID for each family
        get_ind_ID = unique ID for each individual
        get_num_gens = number of generations per pedigree
        get_num_children = number of children each pair produces
        get_gender = assign gender to each individual
        initialize_founders = generate a founder pair for pedigree
        make_gen2 = make a second generation from founder pair
        initialize_gen2_couples = make pairs using second generation
    '''

    family_ID = 0
    ind_ID = 0

    def __init__(self):
        '''initializes family with a unique family ID'''
        Family.family_ID += 1

    def get_family_ID(self):
        '''returns unique family ID'''
        return self.family_ID

    def get_ind_ID(self):
        '''returns unique individual ID'''
        Family.ind_ID += 1
        return self.ind_ID

    def get_num_gens(self):
        '''
        randomly assigns a number of generations to a family instance
        with minimum value of 2 and maximum value of 4
        '''
        num_gens = random.randint(2,4)
        return num_gens

    def get_num_children(self):
        '''
        randomly assigns number of children to a couple. Assumes minimum
        value of 1 and maximum value of 10
        '''
        num_children = random.randint(1,10) 
        return num_children

    def get_gender(self):
        '''
        randomly assigns gender to an individual 1 = male, 2 =
        female
        '''
        gender = random.randint(1,2)
        return gender

    def initialize_founders(self):
        '''
        assigns founder pair same unique family ID, unique individual
        ID, gender, and number of children

        returns a list inf the format [Family ID Number, (Father ID
        Number, Gender), (Mother ID Number, Gender), Number of Children,
        Number of Generations]
        '''
        founder_pair = []
        fam_ID = self.get_family_ID()
        num_children = self.get_num_children()
        num_gens = self.get_num_gens()
        founder_pair.append(fam_ID)
        founder_pair.append((self.get_ind_ID(), 1))
        founder_pair.append((self.get_ind_ID(), 2))
        founder_pair.append(num_children)
        founder_pair.append(num_gens)
        return founder_pair

    
#to debug initialize founders
#founder_list = []
#x = 0
#while x < 10:
#    new_fam = Family()
#    new_found = new_fam.initialize_founders()
#    founder_list.append(new_found)
#    x += 1
#print founder_list


    def make_gen2(self, founder_pair):
        '''
        makes the second generation given a founder pair

        returns a list of lists representing each child of founder pair
        [Family ID Number, Individual ID Number, Gender, Father ID
        Number, Mother ID Number, Number of People in Generation, 
        Number of Generations in Family]
        '''
        fam_ID = founder_pair[0]
        num_children = founder_pair[3]
        father_ID = founder_pair[1][0]
        mother_ID = founder_pair[2][0]
        num_gens = founder_pair[4]
        gen2 = []
        for child in range(num_children):
            child_ID = self.get_ind_ID()
            child_gender = self.get_gender()
            child_info = [fam_ID, child_ID, child_gender, father_ID,
                          mother_ID, num_children, num_gens]
            gen2.append(child_info)
        return gen2
    
#to debug make_gen2
#gen2_list = []
#x = 0
#while x < 10:
#    new_fam = Family()
#    new_found = new_fam.initialize_founders()
#    gen2 = new_fam.make_gen2(new_found)
#    gen2_list.append(gen2)
#    x += 1
#print gen2_list

    
    def initialize_gen2_paris(self, founder_pair, gen2):
        '''
        assigns a partner of opposite gender to every individual in the
        second generation given a founder pair and list of individuals
        in the second generation

        returns a list of lists in the format
        [Family ID Number, (Father ID Number, Gender), (Mother ID
        Number, Gender), Number of Children, Number of Generations in Family]
        '''
        new_pairs = []
        num_founder_children = founder_pair[3]
        num_gens = founder_pair[4]
        for family in range(len(gen2)-(len(gen2)-1)):
            for person in range(len(gen2)):
                fam_ID = gen2[person][0]
                parent1_ID = gen2[person][1]
                parent1_gender = gen2[person][2]
                parent2_ID = self.get_ind_ID()
                num_children = self.get_num_children()
                if parent1_gender == 1:
                    parent2_gender = 2
                    new_pairs.append([fam_ID,
                                      (parent1_ID, parent1_gender),
                                      (parent2_ID, parent2_gender),
                                      num_children, num_gens])
                else:
                    parent2_gender = 1
                    new_pairs.append([fam_ID,
                                      (parent2_ID, parent2_gender),
                                      (parent1_ID, parent1_gender),
                                      num_children, num_gens])
        return new_pairs

#to debug initialize_gen2_pairs
#gen2_list = []
#gen2_pairs_list = []
#x = 0
#while x < 5:
#    new_fam = Family()
#    new_found = new_fam.initialize_founders()
#    gen2 = new_fam.make_gen2(new_found)
#    gen2_list.append(gen2)
#    gen2_pairs = new_fam.initialize_gen2_paris(new_found, gen2)
#    gen2_pairs_list.append(gen2_pairs)
#    x += 1
#print "Second Generation", gen2_list
#print "Second Generation Pairs", gen2_pairs_list


    def make_gen3(self, gen2_pairs):
        '''
        makes the third generation given second generation pairs

        returns a list of lists representing each child of second
        generation pairs in the format:
        [Family ID Number, Individual ID Number, Gender, Father ID
        Number, Mother ID Number, Number of People in Generation, 
        Number of Generations in Family]
        '''
        gen3 = []
        for family in range(len(gen2_pairs)-(len(gen2_pairs)-1)):
            for pair in range(len(gen2_pairs)):
                fam_ID = gen2_pairs[pair][0]
                father_ID = gen2_pairs[pair][1][0]
                mother_ID = gen2_pairs[pair][2][0]
                num_children = gen2_pairs[pair][3]
                num_gens = gen2_pairs[pair][4]
                for child in range(num_children):
                    child_ID = self.get_ind_ID()
                    child_gender = self.get_gender()
                    child_info = [fam_ID, child_ID, child_gender,
                                  father_ID, mother_ID, num_children,
                                  num_gens]
                    gen3.append(child_info)
        return gen3

#to debug make_gen3
#gen2_list = []
#gen2_pairs_list = []
#gen3_list = []
#x = 0
#while x < 10:
#    new_fam = Family()
#    new_found = new_fam.initialize_founders()
#    gen2 = new_fam.make_gen2(new_found)
#    gen2_list.append(gen2)
#    gen2_pairs = new_fam. initialize_gen2_paris(new_found, gen2)
#    gen2_pairs_list.append(gen2_pairs)
#    gen3 = new_fam.make_gen3(gen2_pairs)
#    gen3_list.append(gen3)
#    x += 1
#print "Second Generation", gen2_list
#print "Second Generation Pairs", gen2_pairs_list
#print "Third Generation", gen3_list
                              

    def initialize_gen3_pairs(self, gen3):
         '''
         assigns a partner of opposite gender to every individual in
         the third generation to every individual in the thrid
         generation given a list of the third generation

         returns a list of lists in the format
         [Family ID Number, (Father ID Number, Gender), (Mother ID
         Number, Gender), Number of Children, Number of Generations]
         '''
         new_pairs = []
         for family in range(len(gen3)-(len(gen3)-1)):
             for person in range(len(gen3)):
                 fam_ID = gen3[person][0]
                 parent1_ID = gen3[person][1]
                 parent1_gender = gen3[person][2]
                 parent2_ID = self.get_ind_ID()
                 num_children = self.get_num_children()
                 num_gens = gen3[person][6]
                 if parent1_gender == 1:
                     parent2_gender = 2
                     new_pairs.append([fam_ID,
                                       (parent1_ID, parent1_gender),
                                       (parent2_ID, parent2_gender),
                                       num_children, num_gens])
                 else:
                     parent2_gender = 1
                     new_pairs.append([fam_ID,
                                       (parent2_ID, parent2_gender),
                                       (parent1_ID, parent1_gender),
                                       num_children, num_gens])
         return new_pairs

##to debug initialize_gen3_pairs
#founder_list = []
#gen2_list = []
#gen2_pairs_list = []
#gen3_list = []
#gen3_pairs_list = []
#x = 0
#while x < 5:
#    new_fam = Family()
#    new_found = new_fam.initialize_founders()
#    founder_list.append(new_found)
#    num_gens = new_found[4]
#    gen2 = new_fam.make_gen2(new_found)
#    gen2_list.append(gen2)
#    gen2_pairs = new_fam.initialize_gen2_paris(new_found, gen2)
#    gen2_pairs_list.append(gen2_pairs)
#    if num_gens >= 3:
#        gen3 = new_fam.make_gen3(gen2_pairs)
#        gen3_list.append(gen3)
#        gen3_pairs = new_fam.initialize_gen3_pairs(gen3)
#        gen3_pairs_list.append(gen3_pairs)
#    x += 1
#print "First Generation"
#for item in founder_list:
#    print item
#print "Second Generation"
#for item in gen2_list:
#    print item
#print "Second Generation Pairs"
#for item in gen2_pairs_list:
#    print item
#print "Third Generation"
#for item in gen3_list:
#    print item
#print "Third Generation Pairs"
#for item in gen3_pairs_list:
#    print item


    def make_gen4(self, gen3_pairs):
        '''
        makes the fourth generation given thrid generation paris

        returns a list of lists representing each child of third
        generation pairs in the format:
        [Family ID Number, Individual ID Number, Gender, Father ID
        Number, Mother ID Number, Number of People in Generation, Number
        of Generations in Family]
        '''
        gen4 = []
        for family in range(len(gen3_pairs)-(len(gen3_pairs)-1)):
            for pair in range(len(gen3_pairs)):
                fam_ID = gen3_pairs[pair][0]
                father_ID = gen3_pairs[pair][1][0]
                mother_ID = gen3_pairs[pair][2][0]
                num_children = gen3_pairs[pair][3]
                num_gens = gen3_pairs[pair][4]
                for child in range(num_children):
                    child_ID = self.get_ind_ID()
                    child_gender = self.get_gender()
                    child_info = [fam_ID, child_ID, child_gender,
                                  father_ID, mother_ID, num_children,
                                  num_gens]
                    gen4.append(child_info)
        return gen4


##to debug make_gen4
#founder_list = []
#gen2_list = []
#gen2_pairs_list = []
#gen3_list = []
#gen3_pairs_list = []
#gen4_list = []
#x = 0
#while x < 5:
#    new_fam = Family()
#    new_found = new_fam.initialize_founders()
#    founder_list.append(new_found)
#    num_gens = new_found[4]
#    gen2 = new_fam.make_gen2(new_found)
#    gen2_list.append(gen2)
#    if num_gens >= 3:
#        gen2_pairs = new_fam.initialize_gen2_paris(new_found, gen2)
#        gen2_pairs_list.append(gen2_pairs)
#        gen3 = new_fam.make_gen3(gen2_pairs)
#        gen3_list.append(gen3)
#        if num_gens == 4:
#            gen3_pairs = new_fam.initialize_gen3_pairs(gen3)
#            gen3_pairs_list.append(gen3_pairs)
#            gen4 = new_fam.make_gen4(gen3_pairs)
#            gen4_list.append(gen4)
#    x += 1
#print "First Generation"
#for item in founder_list:
#    print item
#print "Second Generation"
#for item in gen2_list:
#    print item
#print "Second Generation Pairs"
#for item in gen2_pairs_list:
#    print item
#print "Third Generation"
#for item in gen3_list:
#    print item
#print "Third Generation Pairs"
#for item in gen3_pairs_list:
#    print item
#print "Fourth Generation"
#for item in gen4_list:
#    print item

                    

    def make_pedigree(self):
        '''
        randomly make a complete pedigree
        
        returns list for generation 1 in the format [Family ID Number,
        (Father ID Number, Gender), (Mother ID Number, Gender), Number
        of Children, Number of Generations in Family]

        returns list of lists for generations 2,3, and 4 
        containing each individual's information
        in the format [Family ID Number, Individual ID Number, Gender,
        Father ID Number, Mother ID Number, Number of People in
        Generation, Number of Generations in Family] 
        '''
        pedigree = []
        founders = self.initialize_founders()
        founder_formatted = [[founders[0],founders[1][0],
                              founders[1][1], "--", "--", 2,
        founders[4]], [founders[0], founders[2][0], founders [2][1],
                       "--", "--", 2, founders[4]]]
                
        pedigree.append(founder_formatted)
        gen2 = self.make_gen2(founders)
        pedigree.append(gen2)
        num_gens = founders[4]
        if num_gens >= 3:
            gen2_pairs = self.initialize_gen2_paris(founders, gen2)
            gen3 = self.make_gen3(gen2_pairs)
            pedigree.append(gen3)
            if num_gens == 4:
                gen3_pairs = self.initialize_gen3_pairs(gen3)
                gen4 = self.make_gen4(gen3_pairs)
                pedigree.append(gen4)

        #for gen in range(len(pedigree)):
        #    print "Generation", gen+1, pedigree[gen]
        return pedigree
        

## to debug make_pedigree
#x = 1
#while x <= 1:
#    print "Family", x
#    new_fam = Family()
#    pedigree = new_fam.make_pedigree()
#    x += 1
#   print pedigree

    def write_pedigree(self, pedigree):
        '''Writes a textfile containing pedigree information'''
        new_f = "pedigree.txt"
        my_pedigree = open(new_f, "w")
        headers = ["Family ID Number", "Individual ID Number",
                   "Gender", "Father ID Number",
                   "Mother ID Number", "Number of People in Generation",
                   "Number of Generations"]
        for item in headers:
            my_pedigree.write("%s \t" % item)
        my_pedigree.write("\n")
        for gen in pedigree:
            for person in gen:
                for item in person:
                    my_pedigree.write("%s \t\t\t" % item)
                my_pedigree.write("\n")
        my_pedigree.close()
    
##to debug write_pedigree
#new_fam = Family()
#pedigree = new_fam.make_pedigree()
#new_fam.write_pedigree(pedigree)

